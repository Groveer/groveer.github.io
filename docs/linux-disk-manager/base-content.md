# 基础知识：分区、格式化、挂载点

## 分区

### 为什么要分区？（不关心可以跳过本章节）

1. 易于管理和使用

在 Windows 上，可以经常看到 `C:`, `D:`, `E:`, `F:` 分区等等。这里的 `C:` 就表示一个分区（虽然这个说法不严谨，但大多数情况确实如此），`C`和`D`分区分别在磁盘的不同空间上，相当于把一块完整的磁盘切割成多个小块，每个小块对应一个分区，这样可以进行分类管理，如`C`分区用于装系统，`D`分区用于装学习资料等等，这样分工明确的分区就有利于管理和使用。

2. 数据隔离与安全

由于将磁盘分割成不同的小块，其中某一个小块的数据损坏了，并不会影响到其他小块（只针对机械硬盘，现代的固态硬盘往往损坏后整个磁盘都没法使用）。

### 分区的方式

分区信息的储存方式有两个标准，MBR 和 GPT，分区之前，必须在两个之中选择一种标准。

GPT 是一种新的标准，随着硬盘的不断增大，正在逐渐地取代MBR，但是现在MBR的也是不少的。

**那么 MBR 和 GPT 有什么区别呢？**

MBR 的意思是“主引导记录”。之所以叫“主引导记录”，是因为它是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。所谓启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。如果 MBR 被覆盖，操作系统就无法启动了。

MBR 支持最大 2TB 磁盘，它无法处理大于 2TB 容量的磁盘。MBR 还只支持最多 4 个主分区——如果想要更多分区，需要创建所谓“扩展分区”，并在其中创建逻辑分区。

GPT 意为 GUID 分区表。（GUID 意为全局唯一标识符）。这是一个正逐渐取代 MBR 的新标准。它和 UEFI 相辅相成——UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。之所以叫作“GUID分区表”，是因为你的驱动器上的每个分区都有一个全局唯一的标识符（globally unique identifier，GUID）——这是一个随机生成的字符串，可以保证为地球上的每一个 GPT 分区都分配完全唯一的标识符。

在 MBR 磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT 在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。

GPT 的硬盘大小要大得多，几乎没有限制，最大可支持 18EB。而主分区的数量也非常多，可以支持多达 128 个主分区，所以在 GPT 中没有扩展分区和逻辑分区的概念，都是主分区，当然也是可以创建逻辑分区，但是没有必要。

### 常见的分区方案

在分区之前介绍一个命令：lsblk，可以列出当前磁盘的分区情况。

```shell
lsblk
```

```shell
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
sda           8:0    0   1.8T  0 disk /mnt/hdd
zram0       253:0    0     8G  0 disk [SWAP]
nvme0n1     259:0    0 238.5G  0 disk
├─nvme0n1p1 259:1    0   300M  0 part /boot/efi
└─nvme0n1p2 259:2    0 238.2G  0 part /home
                                      /
```

可以看出这台机器上有三个磁盘（sda, zram0, nvme0n1）和两个分区（nvme0n1p1, nvme0n1p2），zram0 先不用管，感兴趣的同学可以阅读本人的另一篇博客[使用zram创建swap分区](/blog/linux-zram.md)。

这里还要介绍一个概念：在 Linux 系统中，一切皆文件，哪怕设备也会被映射为文件来进行访问。而磁盘设备就会被当作设备文件来处理，`lsblk`命令列出的磁盘设备都可以在`/dev`目录下找到，如`/dev/sda`就表示`sda`磁盘；`/dev/nvme0n1p1`就表示`nvme0n1p1`分区。

另外，进行分区时需要使用`fdisk`命令。关于 fdisk 命令的使用方式，可以在分区模式中输入`m`来获取帮助，这里大概说一下常用的命令：

```shell
| o | 创建 MBR 分区表
| g | 创建 GPT 分区表
| n | 添加一个新分区
| q | 不保存就退出
| d | 删除一个分区
| w | 保存退出
| t | 改变系统id号
```

#### MBR

两个分区：根分区和 home 分区

使用`fdisk`进入分区模式：

```shell
fdisk /dev/sda
```

然后依次输入：

1. `o`+回车，创建 MBR 分区表；
2. `n`+回车（多次），新建一个分区；
3. `n`+回车（多次），再次新建一个分区；
4. `w`+回车，保存并退出。

完成后大概是这个样子：

```shell
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
sdb           8:16   1  28.9G  0 disk
├─sdb1        8:17   1    10G  0 part
└─sdb2        8:18   1  18.9G  0 part
```

> 由于本人对`/dev/sdb`这个磁盘设备进行的分区操作，所以显示为 sdb，而不是 sda。

::: warning 注意
在第`2`步中若想继续创建后面的分区，在回车时，有个选项是选择最后一个扇区，这里不要默认回车，否则会使用所有的磁盘空间，这样的话就没办法继续创建下一个分区了。当然，如果不小心已经默认使用了所有的空间，还有使用`d`命令删除刚刚创建的分区，然后重新创建即可。在选择最后一个扇区时，可以使用`+20G`这种方式来指定当前分区需要分多大的空间。
:::

#### GPT

三个分区：efi 分区、根分区和 home 分区

同样使用`fdisk`进入分区模式：

```shell
fdisk /dev/nvme0n1
```

这里以常见的固态硬盘举例，依次输入：

1. `g`+回车，创建 GPT 分区表；
2. `n`+回车（多次），新建一个分区；
3. `n`+回车（多次），再次新建一个分区；
4. `n`+回车（多次），再次新建一个分区；
5. `w`+回车，保存并退出。

::: warning 注意
在进行第`2`,`3`步时同理，需要指定分区大小，而不是使用默认大小，否则会导致当前分区使用全部磁盘空间，无法创建后面的分区。单位除了`G`，还有`M`，如第一个分区指定为 300m，可以使用`+300M`这种方式。
:::

采用 gpt 分区时，一般第一个分区为`efi`分区，所以需要设置一下分类类型，可以使用 fdisk 再次对 `/dev/nvme0n1` 进行设置，也可以在上面第`5`步之前进行下面的步骤：

1. `t`+回车，修改分区类型；
2. `1`+回车，修改第一个分区；
3. `1`+回车，修改第一个分区类型为`efi`分区；
4. `w`+回车，保存并退出。

::: tip 提示
若不是安装系统，可以忽略该步骤！
:::

最终的结果类似这样：

```shell
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
nvme0n1       8:16   1  28.9G  0 disk
├─nvme0n1p1   8:17   1   300M  0 part
├─nvme0n1p2   8:18   1    10G  0 part
└─nvme0n1p3   8:19   1  18.6G  0 part
```

## 格式化

分完区之后，若想正式使用这些分区，还需要对分区进行格式化，进行格式化的目的就是使用一种文件系统对磁盘进行初始化，以便于操作系统对文件进行管理和访问。

不同于 Windows 中的文件系统，常用的只有`FAT32`和`NTFS`两种，Linux 中的文件系统非常丰富，选择性有很多，比较常见的有`EXT4`、`BTRFS`、`XFS`等。他们各有优缺点，简单来说就是`EXT4`兼容性最好，最稳定，但不支持一些高级特性；`BTRFS`功能强大，使用灵活，但却反稳定性；`XFS`对大文件处理较好，速度快，但对小文件不友好。

本篇文件先使用`EXT4`进行格式化，至于其他文件系统，放在后续的文章进行说明。

对于`efi`分区，一般使用`FAT32`文件系统：

```shell
mkfs.fat -F32 /dev/nvme0n1p1
```

其他分区使用`EXT4`文件系统：

```shell
mkfs.ext4 /dev/nvme0n1p2
mkfs.ext4 /dev/nvme0n1p3
```

查看格式化结果：

```shell
lsblk -f
```

`-f`参数可以查看磁盘设备的文件系统：

```shell
NAME        FSTYPE FSVER LABEL      UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
nvme0n1
├─nvme0n1p1 vfat   FAT32            2018-32FB
├─nvme0n1p2 ext4   1.0              6aefcdbd-d69a-4e3e-95d3-abb9cb514a05
└─nvme0n1p3 ext4   1.0              92f75d1d-b348-411d-97a3-a01fd50bbde9
```

> MBR 引导的分区可以全部格式化为`EXT4`文件系统。

## 挂载点

前面提到，Linux 系统中一切皆文件，这里要介绍一下另一个知识点，那就是 Linux 系统中没有所谓的盘符，不存在`C:`,`D:`,`E:`,`F:`这样的盘符，Linux 中的文件都是以目录的方式存放，最顶层的目录是`/`，也就是常说的根目录。

那么这跟挂载点有啥关系呢？由于目录是树形结构，可以将整个根文件系统想象成一棵树，最下面的主干就是根`/`，越向上枝干越多，这些枝干都是一个个目录，一棵树的容量是有限的（磁盘/分区容量），那么是否可以扩展容量呢？答案是可以的，可以想象一下，在某个枝干上挂一个包裹，让这个枝干使用包裹中容量，而不是根中的容量，这样就无形中扩展的根的容量，所有在这个枝干上生长的树叶都是存放在刚刚挂在上面这个包裹管理。

可能使用树来形容挂载点可能并不是很形象，但是原理就是这样，通过挂载点，一个目录结构可以使用很多块磁盘或分区，而这些磁盘或分区中保存着不同目录的文件，组合在一起就是一个完整的目录树，并且 Linux 还对其目录结构做了一些规范定义，定义哪类文件应该存在哪些目录，感兴趣的同学可以看看[FHS_3.0](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html)。

### 挂载分区

想要挂载某个分区很简单：

```shell
mount /dev/nvme0n1p2 /mnt
```

上面这条命令就是将`/dev/nvme0n1p2`分区挂载到`/mnt`目录下。

在挂载之前，/mnt 目录中的文件会保存在根分区下面，而挂载之后就会保存在新挂载的分区下面了，而且卸载后可以看到新分区里面保存的文件会消失不见，原来的文件会重新出现。

卸载的命令也很简单：

```shell
umount /dev/nvme0n1p2
```

或

```shell
umount /mnt
```

## 总结

至此，关于磁盘管理方便的基本知识算是讲完了，学完这些知识可以对 Linux 磁盘管理有一些基本的了解，磁盘管理当前不仅仅是这么简单，像 lvm、btrfs 等高级特性将在后面的内容进行讲解。
